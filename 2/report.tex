\documentclass{paper}

%\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{subcaption}
\usepackage{caption}


% load package with ``framed'' and ``numbered'' option.
%\usepackage[framed,numbered,autolinebreaks,useliterate]{mcode}

% something NOT relevant to the usage of the package.
\setlength{\parindent}{0pt}
\setlength{\parskip}{18pt}






\usepackage[latin1]{inputenc} 
\usepackage[T1]{fontenc} 

\usepackage{listings} 
\lstset{% 
   language=Matlab, 
   basicstyle=\small\ttfamily, 
} 



\title{Report Computer Vision Project 2}



\author{Single Michael\\08-917-445}
% //////////////////////////////////////////////////


\begin{document}



\maketitle


\section{Binocular Stereo (Due on 28/10/2014)}



\subsection{Epipolar lines Estimation (50 points)}
For given two images - called left and right - both showing a certain object from different viewing positions (i.e. Multiview geometry) we were supposed to estimate the epipolar lines in both images. Epipolar lines are the intersections of epipolar plane with the image plane. Furthermore, when selecting a point from the left image, our program should be able to estimate the corresponding point in the right image. \\

Initially, a user has to select a certain point in the left image and then mark the corresponding position in the right image by clicking at the appropriate position. For each click a user performs we store the corresponding image coordinates at the position where the user performed its click action and also remember from which image this click came from. We store these image coordinates as two dimensional homogenous positions. Remember that two-dimensional homogenous coordinates that represents a point in space have three components, where the last is equal one and the first two correspond to the regular cartesian coordinates of the clicked image position. A user has to mark in both images eight positions using our GUI, alternating, first in the left, then in the right image the corresponding position. The collected homogenous coordinates resulting from the selection-process in the left image are both stored in a $3 \times 8$ matrix called \emph{left} (each column represents a homogenous point). Similarly, the collected selections in the right image are stored in a $3 \times 8$ matrix called \emph{right}. \\

Using these \emph{left} and \emph{right} positions we compute (estimate) the fundamental matrix $F$ by applying the \emph{normalized eight point algorithm} on them. This algorithm is called \emph{normalized} since all selected positions from the left image and those from the right image are centred towards their mean center which is supposed to denote the approximate image origin $(0,0)$ (each image has its own origin). \\ 

The normalization process for a given set of points works as the following: using the (x,y) from a set of points (in our case a matrix carrying homogenous coordinates), we compute the mean position by summing all positions and dividing by the number of used points (in this exercise this is equal to eight points). Then, we shift all the given point positions towards this center by subtracting each position by their mean position. \\

In order to increase the numerical stability of the eight-point algorithm, we are supposed to ensure, that the mean squared distance between the origin (i.e. the mean position of the point set) and each point is equal to 2 pixels. \\

Thus, we also have to rescale each point in the left and in the right position collection by a factor $s = \frac{\sqrt{2}}{\bar{d}}$ where $\bar{d}$ denotes the average distance of all point distances (of the points in a certain point set) to their average position (i.e. their origin). Since we are using homogenous coordinates, we can formulate this \emph{position normalization} as a homogenous transformation, capturing a translation towards the average position, and a rescaling such that the mean squared distance to the origin is equal to two pixels. Formally, such a transformation looks like the following:

\begin{align*}
T = \left(\begin{array}{ccc}
s & 0 & -c_1 s \\
0 & s & -c_2 s \\
0 & 0 & 1 \\
\end{array} \right)
\end{align*}


Where the scaling factor $s$ is the distance scaling (such that the mean squared distance of each position to the origin is equal two pixels) and $(-s c_1, -s c_2)$ is the translation to the origin. \\

For both point sets, \emph{left} and \emph{right}, we have to compute such a homogenous transformation matrix. Then we have to apply these transformations to their points. We denote the normalization transformation for the left point set as $T_{l}$ and for the right point set as $T_{r}$. \\

Next, let us consider the two points $\textbf{x} = (u,v,1)^{T}$ and $\textbf{x'} = (u',v',1)^{T}$ where $\textbf{x}$ is a normalized point from the left image (using $T_l$) and $\textbf{x'}$ a normalized point from the right image. \\

Given the following epipolar constraint 

\begin{align}
    \textbf{x'}^{T} F \textbf{x} = 0
\label{eq:epipolar_constraint}
\end{align}

Where $F$ denotes the (yet) unknown Fundamental matrix we are looking for. By solving the minmizing problem 
\begin{align}
    \min_{\bf{F}} \sum^{N}_{k=1} \left(\textbf{x'}_{k}^{T} \textbf{F} \textbf{x}_{k}\right)^2 s.t. ||\textbf{F}||^2 = 1
\label{eq:min_problem}
\end{align}
 We we can therefore retrieve $F$. \\
 In the following I describe some further steps in detail how to compute the fundamental matrix $F$ using above's insights. \\

We start by explicitly showing all components in the epipolar constraint from equation $\ref{eq:epipolar_constraint}$: 

\begin{align}
\left(\begin{array}{ccc}
u' & v' & 1
\end{array}
\right)
\left(\begin{array}{ccc}
f_{11} & f_{12} & f_{13} \\
f_{21} & f_{22} & f_{23} \\
f_{31} & f_{32} & f_{33} \\
\end{array} \right)
\left(\begin{array}{c}
u \\
v \\
1
\end{array}
\right)
= 0
\label{eq:fundamental_matrix_block_form}
\end{align}

which is the same as

\begin{align*}
\left(\begin{array}{ccccccccc}
u' u & u' v & u' & v' u & v' v & v' & u & v & 1
\end{array}
\right)
\cdot
\left(\begin{array}{c}
f_{11} \\
f_{12} \\
f_{13} \\
f_{21} \\
f_{22} \\
f_{23} \\
f_{31} \\
f_{32} \\
f_{33}
\end{array}
\right)
= 0
\end{align*}

Let us define 

\begin{equation}
Y = 
\left(\begin{array}{ccccccccc}
u' u & u' v & u' & v' u & v' v & v' & u & v & 1
\end{array}
\right)
\end{equation}



and 

\begin{equation}
    f = \left(\begin{array}{c}
f_{11} \\
f_{12} \\
f_{13} \\
f_{21} \\
f_{22} \\
f_{23} \\
f_{31} \\
f_{32} \\
f_{33}
\end{array}
\right)
\end{equation}

thus, we solving 
\begin{equation}
 Y \cdot f = 0
\end{equation}

will solve the equation $\ref{eq:min_problem}$. Such a system of equations can usually be solved by using a SVD docompositon of the system. We choose f as the left singular vector that corresponds to the smallest singular value of $Y$. Thus let us apply the singular value decomposition on $Y$:

\begin{equation}
    Y = U \Sigma V^{T}
\label{eq:svd_y}
\end{equation}

Where U,V are orthonormal (rotation) matrices (i.e. $U U^{T} = I = U^{T} U$ same for V), and $\Sigma$ is a diagonal matrix containing all singular values of $Y$ in an ascending order. This means, the highest singular values is the first diagonal element, the smalles singular value is the last diagonal element of $\Sigma$. \\

Since we are interested in the left singular vector that corresponds to the the smallest singular values in $\Sigma$ we have to take the last column of $U$. Therefore we assign f by the last column of U, i.e. 

\begin{equation}
    f = \left(\begin{array}{c}
U_{19} \\
U_{29} \\
U_{39} \\
U_{49} \\
U_{59} \\
U_{69} \\
U_{79} \\
U_{89} \\
U_{99}
\end{array}
\right)
\end{equation}
 
Going back to the definition from equation $\ref{eq:fundamental_matrix_block_form}$ of the fundamental matrix $F$ we get

\begin{align}
\left(\begin{array}{ccc}
U_{19} & U_{29} & U_{39} \\
U_{49} & U_{59} & U_{69} \\
U_{79} & U_{89} & U_{19} \\
\end{array} \right)
\end{align}


Next we have to enforce the rank-2 constraint by setting the smallest singular value of F's SVD to zero. Formally, this corresponds to decompose F into its SVD components, set the last component of its matrix $\Sigma$ to zero and compute 

\begin{align}
    F_{rank=2} = U \Sigma' V^{T}
\end{align}

where $\Sigma$ denotes the modified $3 \times 3$ singular value diagonal matrix $\Sigma$ with the last singular value set to zero. \\

the last remaining step is to transform the fundamental matrix $F_{rank=2}$ back to original units. This can be achieved by multiplying the point-set normalization matrices $T_l$ and $T_r$ to $F_{rank=2}$:

\begin{equation}
    F = T_{r}^{T} F_{rank=2} T_{l} 
\label{eq:fundamental_matrix_rank2_final}
\end{equation}

This final transformation undoes all previous unit transformations (resulted from transforming into left image, right image positions). The matrix $F$ from equation $\ref{eq:fundamental_matrix_rank2_final}$ denotes the Fundamental matrix fulfilling the rank two constraint used in order to estimate the epiplar geometry. \\

Next, we use $F$ and apply the following epipolar constraints to it:

\begin{align*}
F e = 0 \\
F^{T} e' = 0 
\end{align*}

Where $e$ is the epipole in the left image and $e'$ denotes the epipole in the right image. We can solve for $e$ and $e'$ by computing the kernel of the matrix $F$ and $F^{T}$ respectively. The cross product between the left epipole and any point in the left image gives us the the coefficients of a general line in a two dimensional space. This will us allow us to fit a line through the left image. \\

Mathematically, this corresponds to:

\begin{equation}
    (a,b,c) = e \times p_{left}
\end{equation}

and then we have to evaluate the line general line quation 

\begin{equation}
    ax + by + c = 0
\end{equation}

We solve this equation for $y$ using $x = [0,lengt(Image_{left})]$. \\

The corresponding epipole line on the right image can be obtained by applying the fundamental matrix to the point selected in the left image. This gives us a vector with three components. We again use these three components as line coefficients for a line though space. \\

In the following I demonstrate some sample results produced by my Matlab code:






 




\subsection{Model reconstruction (50 points)}


\end{document}